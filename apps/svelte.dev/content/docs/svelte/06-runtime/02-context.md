---
NOTE: do not edit this file, it is generated in apps/svelte.dev/scripts/sync-docs/index.ts
title: Context
---

Context を使うと、コンポーネントは親コンポーネントが所有する値に、 props を介さずアクセスできます。(中間コンポーネントを何層も経由する'prop-drilling'という手法を回避できます。) 親コンポーネントは `setContext(key, value)` で context を設定します...

```svelte
<!--- file: Parent.svelte --->
<script>
	import { setContext } from 'svelte';

	setContext('my-context', 'hello from Parent.svelte');
</script>
```

...そして、子コンポーネントは `getContext` で context を取得します:

```svelte
<!--- file: Child.svelte --->
<script>
	import { getContext } from 'svelte';

	const message = getContext('my-context');
</script>

<h1>{message}, inside Child.svelte</h1>
```

これは、 `Parent.svelte` が `Child.svelte` を直接含んでおらず, `children` [snippet](snippet) の一部としてレンダリングするとき、特に便利です。 ([デモ](/playground/untitled#H4sIAAAAAAAAE42Q3W6DMAyFX8WyJgESK-oto6hTX2D3YxcM3IIUQpR40yqUd58CrCXsp7tL7HNsf2dAWXaEKR56yfTBGOOxFWQwfR6Qz8q1XAHjL-GjUhvzToJd7bU09FO9ctMkG0wxM5VuFeeFLLjtVK8ZnkpNkuGo-w6CTTJ9Z3PwsBAemlbUF934W8iy5DpaZtOUcU02-ZLcaS51jHEkTFm_kY1_wfOO8QnXrb8hBzDEc6pgZ4gFoyz4KgiD7nxfTe8ghqAhIfrJ46cTzVZBbkPlODVJsLCDO6V7ZcJoncyw1yRr0hd1GNn_ZbEM3I9i1bmVxOlWElUvDUNHxpQngt3C4CXzjS1rtvkw22wMrTRtTbC8Lkuabe7jvthPPe3DofYCAAA=)):

```svelte
<Parent>
	<Child />
</Parent>
```

キー (上記の例では `'my-context'`) と context 自体を、任意の JavaScript の値にすることができます。

[`setContext`](svelte#setContext) と [`getContext`](svelte#getContext) に加えて、 Svelte は [`hasContext`](svelte#hasContext) と [`getAllContexts`](svelte#getAllContexts) 関数を提供しています。

## state と context を使用する <!--Using-context-with-state-->

リアクティブな state を context に保存できます ([デモ](/playground/untitled#H4sIAAAAAAAAE41R0W6DMAz8FSuaBNUQdK8MkKZ-wh7HHihzu6hgosRMm1D-fUpSVNq12x4iEvvOx_kmQU2PIhfP3DCCJGgHYvxkkYid7NCI_GUS_KUcxhVEMjOelErNB3bsatvG4LW6n0ZsRC4K02qpuKqpZtmrQTNMYJA3QRAs7PTQQxS40eMCt3mX3duxnWb-lS5h7nTI0A4jMWoo4c44P_Hku-zrOazdy64chWo-ScfRkRgl8wgHKrLTH1OxHZkHgoHaTraHcopXUFYzPPVfuC_hwQaD1GrskdiNCdQwJljJqlvXfyqVsA5CGg0uRUQifHw56xFtciO75QrP07vo_JXf_tf8yK2ezDKY_ZWt_1y2qqYzv7bI1IW1V_sN19m-07wCAAA=))...

```svelte
<script>
	import { setContext } from 'svelte';
	import Child from './Child.svelte';

	let counter = $state({
		count: 0
	});

	setContext('counter', counter);
</script>

<button onclick={() => counter.count += 1}>
	increment
</button>

<Child />
<Child />
<Child />
```

...ただし、 `counter` を _再代入する_ (更新ではなく)と「リンクが切れる」点に注意してください。 つまり、次のようにするのではなく...

```svelte
<button onclick={() => counter = { count: 0 }}>
	reset
</button>
```

...次のようにします:

```svelte
<button onclick={() => +++counter.count = 0+++}>
	reset
</button>
```

もしあなたが間違えても、 Svelte が警告してくれます。

## 型安全な context <!--Type-safe-context-->

便利なパターンとして、型安全性を維持できるヘルパー関数で `setContext` と `getContext` の呼び出しをラップする方法があります:

```js
/// file: context.js
// @filename: ambient.d.ts
interface User {}

// @filename: index.js
// ---cut---
import { getContext, setContext } from 'svelte';

const key = {};

/** @param {User} user */
export function setUserContext(user) {
	setContext(key, user);
}

export function getUserContext() {
	return /** @type {User} */ (getContext(key));
}
```

## グローバル state の置き換え<!--Replacing-global-state-->

多くの異なるコンポーネントで共有される state があるとき、 state を独自のモジュールに配置し、必要に応じてインポートしたくなるかもしれません:

```js
/// file: state.svelte.js
export const myGlobalState = $state({
	user: {
		// ...
	}
	// ...
});
```

大部分のケースではまったく問題ありませんが、リスクがあります。サーバーサイドレンダリング中に state を変更すると(これは非推奨ですが、完全に可能です！)...

```svelte
<!--- file: App.svelte ---->
<script>
	import { myGlobalState } from './state.svelte.js';

	let { data } = $props();

	if (data.user) {
		myGlobalState.user = data.user;
	}
</script>
```

...すると、そのデータに _次の_ ユーザーがアクセスできる可能性があります。 context はリクエスト間で共有されないため、この問題を解決します。