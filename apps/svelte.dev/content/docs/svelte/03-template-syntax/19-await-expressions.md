---
NOTE: do not edit this file, it is generated in apps/svelte.dev/scripts/sync-docs/index.ts
title: await
---

Svelte5.36 以降、コンポーネント内のうち、これまで使えなかった3箇所で `await` キーワードを使えるようになりました:

- コンポーネントの `<script>` トップレベル
-  `$derived(...)` 宣言の内部
- マークアップの内部

この機能は実験的なものであり、Svelteの[設定](/docs/kit/configuration)(通常は `svelte.config.js`)に `experimental.async` オプションを追加して、明示的に有効にする必要があります:

```js
/// file: svelte.config.js
export default {
	compilerOptions: {
		experimental: {
			async: true
		}
	}
};
```

この実験的なフラグは Svelte 6 で削除される予定です。

## Boundary(境界) <!--Boundaries-->

現在、 `await` は `pending` snippetを持つ [`<svelte:boundary>`](svelte-boundary) の内部でのみ使えます:

```svelte
<svelte:boundary>
	<MyApp />

	{#snippet pending()}
		<p>loading...</p>
	{/snippet}
</svelte:boundary>
```

この制限は、 Svelte が非同期のサーバーサイドレンダリングをサポートするようになれば解除されます([注意事項](#Caveats)を参照)。

> [!NOTE] [プレイグラウンド](/playground)では、アプリは空の pending snippet を持つ boudary 内でレンダリングされるため、自分で作成しなくても `await` を使えます。

## 同期された更新 <!--Synchronized-updates-->

ある `await` 式が特定の state に依存しているとき、その state への変更は、非同期処理が完了するまでUIに反映されません。UIが矛盾した状態にならないようにするためです。つまり、[こちら](/playground/untitled#H4sIAAAAAAAAE42QsWrDQBBEf2VZUkhYRE4gjSwJ0qVMkS6XYk9awcFpJe5Wdoy4fw-ycdykSPt2dpiZFYVGxgrf2PsJTlPwPWTcO-U-xwIH5zli9bminudNtwEsbl-v8_wYj-x1Y5Yi_8W7SZRFI1ZYxy64WVsjRj0rEDTwEJWUs6f8cKP2Tp8vVIxSPEsHwyKdukmA-j6jAmwO63Y1SidyCsIneA_T6CJn2ZBD00Jk_XAjT4tmQwEv-32eH6AsgYK6wXWOPPTs6Xy1CaxLECDYgb3kSUbq8p5aaifzorCt0RiUZbQcDIJ10ldH8gs3K6X2Xzqbro5zu1KCHaw2QQPrtclvwVSXc2sEC1T-Vqw0LJy-ClRy_uSkx2ogHzn9ADZ1CubKAQAA)のような例では...

```svelte
<script>
	let a = $state(1);
	let b = $state(2);

	async function add(a, b) {
		await new Promise((f) => setTimeout(f, 500)); // artificial delay
		return a + b;
	}
</script>

<input type="number" bind:value={a}>
<input type="number" bind:value={b}>

<p>{a} + {b} = {await add(a, b)}</p>
```

...`a` の値をインクリメントしても、 `<p>` の内容は次のようには _なりません。_

```html
<p>2 + 2 = 3</p>
```

実際には、`add(a, b)`が解決されたときに、`<p>`の内容を `2 + 2 = 4` に更新します。

更新は重複することがあります。先行する更新が遅く、まだ進行中であっても、続く更新が速ければ、速いほうが先にUIに反映されます。

## 並行性 <!--Concurrency-->

Svelte は可能な限り非同期処理を並行におこないます。例えば、マークアップ内に2つの `await` 式があるとき...

```svelte
<p>{await one()}</p>
<p>{await two()}</p>
```

...それらは独立した式ですので、 _見た目上は_ 順次実行されているように見えても、両方の関数が同時に実行されます。

これは、`<script>` 内や非同期関数内の連続した `await` 式には適用されません。これらは他の非同期JavaScriptと同じように実行されます。例外として、独立した `$derived` 式は、最初の作成時には順次実行されますが、そのあとは独立して更新されます:

```js
async function one() { return 1; }
async function two() { return 2; }
// ---cut---
// これらは最初は順次実行されますが、
// そのあとは独立して更新されます
let a = $derived(await one());
let b = $derived(await two());
```

> [!NOTE] このようなコードを書くと、Svelteから [`await_waterfall`](runtime-warnings#Client-warnings-await_waterfall) 警告が表示されます。

## ローディング状態の表示<!--Indicating-loading-states-->

`await` によるローディング状態は、それを囲むもっとも内側の `<svelte:boundary>` に定義された [`pending`](svelte-boundary#Properties-pending) によって表示されます。それに加えて、 [`$effect.pending()`]($effect#$effect.pending) を使っても、非同期処理が進行中であることを示せます。

また、 [`settled()`](svelte#settled) を使うと、現在の更新が完了したときに解決(resolve)される Promise を取得できます:

```js
let color = 'red';
let answer = -1;
let updating = false;
// ---cut---
import { tick, settled } from 'svelte';

async function onclick() {
	updating = true;

	// これがないと、`updating` への変更は
	// 他の変更とまとめられてしまうため、
	// UI に反映されません
	await tick();

	color = 'octarine';
	answer = 42;

	await settled();

	// `color` や `answer` の変更に影響される
	// あらゆる更新が、この時点で適用済みになります
	updating = false;
}
```

## エラーハンドリング <!--Error-handling-->

`await` 式のエラーは、もっとも近い [error boundary](svelte-boundary) に伝播します。

## 注意事項 <!--Caveats-->

実験的な機能であるため、 `await` 扱いの詳細(および `$effect.pending()` のような関連API)は、セマンティックバージョニングのメジャーリリース外では破壊的変更がおこなわれる可能性があります。ただし、そのような変更は最小限に抑えるつもりです。

現在、サーバーサイドレンダリングは同期的です。SSR中に `pending` snippet を持つ `<svelte:boundary>` が検出されたとき、 `pending` snippet のみがレンダリングされます。

## 破壊的変更 <!--Breaking-changes-->

`experimental.async` オプションが `true` のとき、効果の実行順序がわずかに異なります。具体的には、 `{#if ...}` や `{#each ...}` のような _ブロック_ の効果を、 `$effect.pre` や `beforeUpdate` の前に実行するようになります。これにより、[非常にまれな状況](/playground/untitled?#H4sIAAAAAAAAE22R3VLDIBCFX2WLvUhnTHsf0zre-Q7WmfwtFV2BgU1rJ5N3F0jaOuoVcPbw7VkYhK4_URTiGYkMnIyjDjLsFGO3EvdCKkIvipdB8NlGXxSCPt96snbtj0gctab2-J_eGs2oOWBE6VunLO_2es-EDKZ5x5ZhC0vPNWM2gHXGouNzAex6hHH1cPHil_Lsb95YT9VQX6KUAbS2DrNsBdsdDFHe8_XSYjH1SrhELTe3MLpsemajweiWVPuxHSbKNd-8eQTdE0EBf4OOaSg2hwNhhE_ABB_ulJzjj9FULvIcqgm5vnAqUB7wWFMfhuugQWkcAr8hVD-mq8D12kOep24J_IszToOXdveGDsuNnZwbJUNlXsKnhJdhUcTo42s41YpOSneikDV5HL8BktM6yRcCAAA=)では、存在しないはずのブロックを更新してしまう可能性があります。ただし、これは効果内で state を更新した場合に限られますし、[そのような状況は避けるべきです]($effect#When-not-to-use-$effect)。
